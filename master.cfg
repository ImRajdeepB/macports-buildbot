# -*- python -*-
# ex: set filetype=python:

import os
import re

from datetime import timedelta
from yaml import load
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader

from buildbot.plugins import (
    util, changes, steps, schedulers, worker, reporters)
from buildbot.steps.trigger import Trigger
from buildbot.schedulers.base import BaseScheduler
from buildbot.process import results
from buildbot.process.properties import Properties, Property


def _path(name):
    return os.path.join(os.path.dirname(__file__), name)


def merge_dicts(*dicts):
    res = {}
    for d in dicts:
        res.update(d)
    return res


def port_from_path(path, sep='/'):
    components = path.split(sep)
    try:
        if (components[0] != '_resources'
                and components[2] in ('Portfile', 'files')):
            return components[1]
    except IndexError:
        pass
    return None


c = BuildmasterConfig = {}

# configure a janitor which will delete all logs older than one month,
# and will run on sundays at noon
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]

c['caches'] = {
    'Changes': 1000,
    'Builds': 5000,
    'chdicts': 100,
    'BuildRequests': 10,
    'SourceStamps': 20,
    'ssdicts': 20,
    'objectids': 10,
    'usdicts': 100,
}

config = {
    # Production or development
    'production': False,

    # Connections
    'workerport': 9989,
    'httpport': 8010,

    # External configuration. Use absolute paths when overriding these.
    'configfile': _path('config.yml'),
    'secretsfile': _path('secrets.yml'),
    'workersfile': _path('workers.yml'),
    'htpasswdfile': _path('htpasswd'),

    # GitHub. Repository URLs must have the '.git' suffix.
    'baseurl': 'https://github.com/macports/macports-base.git',
    'mpbburl': 'https://github.com/macports/mpbb.git',
    'portsurl': 'https://github.com/rajdeepbharati/macports-ports.git',  # change here
    'wwwurl': 'https://github.com/macports/macports-www.git',
    'guideurl': 'https://github.com/macports/macports-guide.git',
    'infraurl': 'https://github.com/macports/macports-infrastructure.git',

    # Tooling
    'workerprefix': '/opt/local',
    'toolsprefix': '/opt/macports-test',
    # 'workerprefix': '/opt/macports-test',
    # 'toolsprefix': '/opt/local',
    'jobstoolsprefix': '/opt/local',

    # Deployment
    'archivesite': 'http://packages.macports.org',
    'archivesiteprivate': 'https://packages-private.macports.org',
    'privkey': '',
    'deploy': {},

    # Site definitions
    'title': 'MacPorts',
    'titleURL': 'https://www.macports.org',
    'buildbotURL': 'http://localhost:8010/',
    # 'buildbotURL': 'http://34.67.147.76/',

    # Database
    'db_url': 'sqlite:///state.sqlite',
}

try:
    with open(config['configfile']) as f:
        extconfig = load(f, Loader=Loader)
except IOError:
    extconfig = {}
config.update(extconfig)

try:
    with open(config['secretsfile']) as f:
        secrets = load(f, Loader=Loader)
except IOError:
    secrets = {}

path_base = '/usr/bin:/bin:/usr/sbin:/sbin'
path_ports = os.path.join(config['toolsprefix'], 'bin') + ':' + path_base
path_jobs = os.path.join(config['jobstoolsprefix'], 'bin') + ':' + path_base


# WORKERS

with open(config['workersfile']) as f:
    workerdata = load(f, Loader=Loader)

build_platforms = workerdata['build_platforms']

c['workers'] = [worker.Worker(name, pwd)
                for name, pwd in workerdata['workers'].items()]

c['protocols'] = {'pb': {'port': 9989}}


# CHANGESOURCES

c['change_source'] = [
    # changes.GitPoller(
    #     config['portsurl'],
    #     workdir='gitpoller-workdir', branch='master',
    #     pollInterval=1),
    # changes.GitHubPullrequestPoller(
    #     owner='am1e',#change here
    #     repo='macports-ports',
    #     token=secrets['githubapitoken'],
    #     pollInterval=1,
    #     pollAtLaunch=True,
    #     branches=['master'],
    #     magic_link=True)
]

# SCHEDULERS

base_platforms = [
    plat for plat in build_platforms
    if 'legacy' not in plat and '10_6_i386' not in plat]
port_platforms = [
    plat for plat in build_platforms
    if 'linux' not in plat and '10_5_ppc' != plat]

base_buildernames = list(map('base_{}'.format, base_platforms))
portwatcher_buildernames = list(map('ports_{}_watcher'.format, port_platforms))
portbuilder_buildernames = list(map('ports_{}_builder'.format, port_platforms))
portbuilder_triggerables = list(map('ports_{}_trigger'.format, port_platforms))
# ports = list(map('ports_{}'.format, port_platforms))

c['schedulers'] = [
    schedulers.SingleBranchScheduler(
        name='base',
        treeStableTimer=5,
        change_filter=util.ChangeFilter(
            repository=config['baseurl'],  # [:-4],
            branch='master'),
        builderNames=base_buildernames),
    schedulers.SingleBranchScheduler(
        name='ports',
        treeStableTimer=5,
        change_filter=util.ChangeFilter(
            category=None,
            repository=config['portsurl'][:-4]),
        # branch='master'),
        # filter_fn=lambda change: any(port_from_path(f) for f in change.files)),
        builderNames=portwatcher_buildernames),
    schedulers.ForceScheduler(
        name='base_force',
        builderNames=base_buildernames), schedulers.ForceScheduler(
        name='portbuilder_force',
        builderNames=portbuilder_buildernames,
        properties=[util.StringParameter(
            name='portname',
            label='Port name:',
            default='',
            required=True)
        ]),
    schedulers.ForceScheduler(
        name='portwatcher_force',
        builderNames=portwatcher_buildernames,
        properties=[util.StringParameter(
            name='portlist',
            label='Port list:',
            default='',
            size=30,
            required=False),
            util.StringParameter(
                name='portexpression',
                label='Port expression:',
                default='',
                required=False)
        ])
]

portbuilders = zip(portbuilder_triggerables, portbuilder_buildernames)
c['schedulers'].extend(schedulers.Triggerable(name=t, builderNames=[b])
                       for t, b in portbuilders)

base_factory = util.BuildFactory()
workdir = 'build'

base_factory.addStep(steps.Git(
    repourl=config['baseurl'],
    branch='master',
    progress=True,
    mode='full',
    method='fresh',
    env={'PATH': path_ports}))
base_factory.addStep(steps.Configure(
    command=['./configure', '--enable-readline',
             '--prefix=/opt/local',
             '--with-applications-dir=/opt/local/Applications',
             #  '--with-install-user=`id -un`',
             #  '--with-install-group=`id -gn`'
             ],
    env={'PATH': ['/usr/bin:/bin:/usr/sbin:/sbin', '${PATH}']},
    logfiles={'config.log': 'config.log'},
    workdir=workdir))
base_factory.addStep(steps.Compile(
    name='make -C vendor',
    command='make -j`sysctl -n hw.activecpu` -C vendor'))
base_factory.addStep(steps.Compile(
    name='make',
    command='make -j`sysctl -n hw.activecpu`'))
base_factory.addStep(steps.ShellCommand(
    command='make install',
    name='install',
    description=['installing'],
    descriptionDone=['install']))
# base_factory.addStep(steps.ShellCommand(
#     command='make test',
#     name='test',
#     description=['testing'],
#     descriptionDone=['test']))
# base_factory.addStep(steps.ShellCommand(
#     # command=util.WithProperties(
#     #     'make distclean; rm -rf %(workdir)s/opt/local'),
#     command=['make distclean'],#;', 'rm -rf /opt/local'],
#     name='clean',
#     description=['cleaning'],
#     descriptionDone=['clean']))


class SetPropertyFromCommandWithPortlist(steps.SetPropertyFromCommand):
    """
    Custom class to make the file list available on the worker...
    """

    def setBuild(self, build):
        super(SetPropertyFromCommandWithPortlist, self).setBuild(build)

        # support forced build properties
        ports = set(self.getProperty('portlist', default='').split())

        # paths should be category/portdir(/...)
        ports.update(
            filter(None, map(port_from_path, self.build.allFiles())))

        self.setProperty('fullportlist', ' '.join(ports))

    def getText(self, cmd, results):
        if self.hasProperty('subportlist'):
            return ['Port list: {}'.format(self.getProperty('subportlist'))]
        # let ShellCommand describe
        return steps.ShellCommand.getText(self, cmd, results)


# can't run with prefix inside the workdir in production,
# because archives must be built with prefix=/opt/local
if config['production']:
    prefix = '/opt/local'
    dlhost = 'packages@packages-origin.macports.org'
    dlhost_private = dlhost
    dlpath = '/var/www/html/packages'
    dlpath_private = '/var/www/html/packages-private'
else:
    prefix = config['workerprefix']
    dlhost = ''
    dlhost_private = dlhost
    dlpath = './deployed_archives'
    dlpath_private = './deployed_archives_private'

ulpath = 'archive_staging'
ulpath_unique = ulpath + '-%(buildername)s'


@util.renderer
def make_build_url(props):
    buildername = props.getProperty('buildername')
    buildnumber = props.getProperty('buildnumber')
    url = c['buildbotURL']
    if not url.endswith('/'):
        url += '/'
    url += 'builders/%s/builds/%s' % (buildername, buildnumber)
    return url


class TriggerWithPortlist(steps.Trigger):
    def getSchedulersAndProperties(self):
        sp = []
        priority = 1
        for scheduler in self.schedulerNames:
            for port in self.build.getProperty('subportlist').split():
                props = self.set_properties.copy()
                props['portname'] = port
                props['priority'] = priority
                priority += 1
                sp.append([scheduler, props])
        return sp

# def new_portwatcher_factory(triggerable):


def make_portwatcher_factory(triggerable):
    portwatcher_factory = util.BuildFactory()
    portwatcher_factory.useProgress = False
    portwatcher_factory.workdir = 'build'

    portwatcher_factory.addStep(steps.Git(
        repourl=config['mpbburl'],
        progress=True,
        env={'PATH': path_ports},
        workdir=os.path.join(portwatcher_factory.workdir, 'mpbb'),
        alwaysUseLatest=True,
        haltOnFailure=True))

    # portwatcher_factory.addStep(steps.ShellCommand(
    #     command=['./mpbb/mpbb', '--prefix',
    #              util.Interpolate(prefix), 'cleanup'],
    #     name='cleanup',
    #     description=['cleaning'],
    #     descriptionDone=['clean']))

    portwatcher_factory.addStep(steps.ShellCommand(
        command=['./mpbb/mpbb', '--prefix',
                 util.Interpolate(prefix), 'selfupdate'],
        name='selfupdate',
        description=['updating', 'MacPorts'],
        descriptionDone=['update', 'MacPorts'],
        haltOnFailure=True))

    portwatcher_factory.addStep(steps.ShellCommand(
        command=['./mpbb/mpbb', '--prefix', util.Interpolate(prefix), 'checkout',
                 '--archive-sites', config['archivesite']
                 + ' ' + config['archivesiteprivate'],
                 '--binpath', '%(prefix)s/bin:%(prefix)s/sbin:%(toolsprefix)s/libexec/libarchive:/bin:/sbin:/usr/bin:/usr/sbin' % {
            'prefix': prefix, 'toolsprefix': config['toolsprefix']},
            '--ports-url', config['portsurl']],
        timeout=3600,
        name='checkout',
        description=['syncing', 'ports'],
        descriptionDone=['sync', 'ports'],
        haltOnFailure=True))

    def extract_subportlist(rc, stdout, stderr):
        """
        Extract function for SetPropertyFromCommand(). Buildbot did not get the
        capability to ignore or distinguish stderr output before 0.9.x, but
        extract_fn always had the option to deal with them separately, so do
        that.
        This is called by SetPropertyFromCommand with the return value of the
        command and strings containing stdout and stderr. The return value
        should be a dictionary of new properties to be set.
        """
        if rc != 0:
            # Set an empty subport list on error
            return {'subportlist': ''}
        subports = [x.strip() for x in stdout.splitlines()]
        return {'subportlist': ' '.join(subports)}

    portwatcher_factory.addStep(SetPropertyFromCommandWithPortlist(
        command=['./mpbb/mpbb', '--prefix', util.Interpolate(prefix), 'list-subports',
                 '--archive-site', config['archivesite'],
                 '--archive-site-private', config['archivesiteprivate'],
                 util.WithProperties('%(fullportlist)s')],
        extract_fn=extract_subportlist,
        name='subports',
        description=['listing', 'subports'],
        haltOnFailure=True))

    def has_subportlist(step):
        return step.hasProperty('subportlist') and step.getProperty('subportlist')

    if 'mirror' in config['deploy']:
        portwatcher_factory.addStep(steps.Trigger(
            name='mirror',
            schedulerNames=['mirror'],
            set_properties={'subportlist': Property(
                'subportlist'), 'triggered_by': make_build_url},
            waitForFinish=True,
            updateSourceStamp=True,
            doStepIf=has_subportlist))

    portwatcher_factory.addStep(TriggerWithPortlist(
        name='portbuilders',
        schedulerNames=[triggerable],
        set_properties={'triggered_by': make_build_url},
        waitForFinish=True,
        updateSourceStamp=True,
        doStepIf=has_subportlist))

    return portwatcher_factory


# portbuilder factory
portbuilder_factory = util.BuildFactory()
portbuilder_factory.useProgress = False
portbuilder_factory.workdir = 'build'
logdir = os.path.join(portbuilder_factory.workdir, 'logs')

portbuilder_factory.addStep(steps.MasterShellCommand(
    command=['python', 'rands.py'],
    workdir='/Users/rajdeep/test-master',
    env={'PATH': ["/Users/rajdeep/goodbb/.venv/bin"]}
))
# portbuilder_factory.addStep(steps.Git(
#     repourl=config['mpbburl'],
#     progress=True,
#     env={'PATH': path_ports},
#     workdir=os.path.join(portbuilder_factory.workdir, 'mpbb'),
#     alwaysUseLatest=True,
#     haltOnFailure=True))

# portbuilder_factory.addStep(steps.Compile(
#     command=['./mpbb/mpbb', '--prefix', util.WithProperties(
#         prefix), 'install-dependencies', util.WithProperties('%(portname)s')],
#     timeout=3600,
#     name='install-dependencies',
#     description=['installing', 'dependencies',
#                  'of', util.WithProperties('%(portname)s')],
#     descriptionDone=['install', 'dependencies',
#                      'of', util.WithProperties('%(portname)s')],
#     logfiles={'dependencies': os.path.join(
#         logdir, 'dependencies-progress.txt')},
#     haltOnFailure=True))

# portbuilder_factory.addStep(steps.Compile(
#     command=['./mpbb/mpbb', '--prefix', util.WithProperties(
#         prefix), 'install-port', util.WithProperties('%(portname)s')],
#     timeout=3600,
#     name='install-port',
#     description=['installing', util.WithProperties('%(portname)s')],
#     descriptionDone=['install', util.WithProperties('%(portname)s')],
#     logfiles={'files': os.path.join(logdir, 'port-contents.txt'),
#               'statistics': os.path.join(logdir, 'port-statistics.txt'),
#               'main.log': os.path.join(logdir, 'main.log')},
#     haltOnFailure=True))

# portbuilder_factory.addStep(steps.ShellCommand(
#     command=['./mpbb/mpbb', '--prefix', util.WithProperties(prefix), 'gather-archives',
#              '--archive-site', config['archivesite'],
#              '--archive-site-private', config['archivesiteprivate'],
#              '--staging-dir', ulpath],
#     name='gather-archives',
#     description=['gathering', 'archives'],
#     descriptionDone=['gather', 'archives'],
#     haltOnFailure=True))

# # portbuilder_factory.addStep(steps.ShellCommand(
# #     command=['./mpbb/mpbb', '--prefix',
# #              util.WithProperties(prefix), 'cleanup'],
# #     name='cleanup',
# #     description=['cleaning'],
# #     descriptionDone=['clean'],
# #     alwaysRun=True))


# BUILDER CONFIG

def getPriority(request):
    if request.properties and request.properties.hasProperty('priority'):
        return int(request.properties.getProperty('priority'))
    else:
        return float('inf')


def getNextBuildOnPortBuilder(builder, requests):
    nextBuild = requests[0]
    for request in requests:
        if getPriority(request) < getPriority(nextBuild):
            nextBuild = request
    return nextBuild


portsworkers = {}
baseworkers = {}
workernames = workerdata['workers'].keys()
for plat in build_platforms:
    baseworkers[plat] = filter(
        lambda x: x.endswith(plat + '_base'), workernames)
    portsworkers[plat] = filter(
        lambda x: x.endswith(plat + '_ports'), workernames)

env_buildinfo = {
    'BUILDBOT_BUILDERNAME': util.WithProperties('%(buildername)s'),
    'BUILDBOT_BUILDNUMBER': util.WithProperties('%(buildnumber)s'),
    'BUILDBOT_BUILDURL': make_build_url
}

c['builders'] = []
extract_os = re.compile(r'10_\d+')

for plat in build_platforms:
    os_match = extract_os.search(plat)
    os_version = os_match.group(0) if os_match else plat
    if 'legacy' not in plat and '10_6_i386' not in plat:
        c['builders'].append(
            util.BuilderConfig(
                name='base_' + plat,
                workernames=['base_' + plat],
                factory=base_factory,
                tags=['base', os_version],
                env=merge_dicts(env_buildinfo, {'PATH': path_base})))
    if 'linux' not in plat and '10_5_ppc' != plat:
        c['builders'].extend((
            util.BuilderConfig(
                name='ports_' + plat + '_watcher',
                workernames=['ports_' + plat],
                factory=make_portwatcher_factory('ports_' + plat + '_trigger'),
                tags=['portwatcher', os_version],
                env=merge_dicts(env_buildinfo, {'PATH': path_ports})),
            util.BuilderConfig(
                name='ports_' + plat + '_builder',
                workernames=['ports_' + plat],
                factory=portbuilder_factory,
                tags=['portbuilder', os_version],
                nextBuild=getNextBuildOnPortBuilder,
                env=merge_dicts(env_buildinfo, {'PATH': path_ports}))
        ))


# PROJECT IDENTITY

c['title'] = config['title']
c['titleURL'] = config['titleURL']
c['buildbotURL'] = config['buildbotURL']

c['www'] = dict(
    port=8010,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={},
        buildbot_macports_custom_views={}),
    change_hook_dialects={
        'github': {
            'secret': 'kreyzig'
        }
    })


c['www']['ui_default_config'] = {
    'BuildbotMacPortsCustomViews.changeLimit': 500,
}

c['db'] = {
    'db_url': config['db_url'],
}
